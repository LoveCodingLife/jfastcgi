     -------
      jFastCGI Reference Documentation
     -------
     -------
      2013-08-10
      -------

Description

   JfastCGI allows a servlet container to act as a fastCGI gateway that serves content generated by a fastCGI producer.
   It gives an original and reliable way for using servlet containers such as tomcat or jetty for serving PHP pages,
   or any other fastCGI application.

Installing the library in your webapp


* Installing manually
   Copy the latest core-x.x.jar and servlet-x.x.jar to the /WEB-INF/lib directory of your web project.

   You also need to have commons-logging.jar in your application's classpath.

   The following jars are optional, only necessary for certain features :

** Pooling of fastCGI connections :

   You will need the commons-pool library (version 1.4 or more) if you want to use the fastCGI responder pooling capability.

* Installing with Maven

--------------
        <!-- add this dependency to use inside a servlet container (tomcat, jetty, etc.) -->
        <dependency>
            <groupId>org.jfastcgi.client</groupId>
            <artifactId>client-servlet</artifactId>
            <version>${project.version}</version>
        </dependency>

        <!-- add this dependency to use inside a servlet container with the Spring Framework -->
        <dependency>
            <groupId>org.jfastcgi.client</groupId>
            <artifactId>client-spring</artifactId>
            <version>${project.version}</version>
        </dependency>


        <!-- add this dependency to use inside a portlet container (liferay, etc.) -->
        <dependency>
            <groupId>org.jfastcgi.client</groupId>
            <artifactId>client-portlet</artifactId>
            <version>${project.version}</version>
        </dependency>

--------------



Portlet support

   portlet.jar (FastCGIPortlet is compatible with jsr168)

Spring integration

   spring-2.5.6 or higher.


Running the simple way : the FastCGIServlet

   In most cases, if you don't want to use pooling/distributing between several fastCGI servers,
   you just have to declare the fastCGI Servlet and declare the address of the external fastCGI program.

-----------------
<servlet>
    <servlet-name>FastCGI</servlet-name>
    <servlet-class>org.jfastcgi.servlet.FastCGIServlet</servlet-class>
    <init-param>
        <param-name>server-address</param-name>
        <param-value>localhost:6666</param-value>
    </init-param>
</servlet>
-----------------

   If the other server is listening to ipv6, specify the server address like this:

-----------------
<servlet>
    <servlet-name>FastCGI</servlet-name>
    <servlet-class>org.jfastcgi.servlet.FastCGIServlet</servlet-class>
    <init-param>
        <param-name>server-address</param-name>
        <param-value>[::1]:6666</param-value>
    </init-param>
</servlet>
-----------------

    If you, for example, use jFastCGI with php, just map the servlet with the php files by adding the <servlet-mapping> configuration in the web.xml :

-----------------
<servlet-mapping>
    <servlet-name>FastCGI</servlet-name>
    <url-pattern>*.php</url-pattern>
</servlet-mapping>
-----------------

    The servlet may optionally be responsible of the fastCGI process and start it for you if necessary.
    Just add the "start-executable" init parameter :

-----------------
<servlet>
    <servlet-name>FastCGI</servlet-name>
    <servlet-class>org.jfastcgi.servlet.FastCGIServlet</servlet-class>
    <init-param>
        <param-name>server-address</param-name>
        <param-value>localhost:6666</param-value>
    </init-param>
    <init-param>
        <param-name>start-executable</param-name>
        <param-value>c:/wamp/bin/php/php5.2.6/php-cgi.exe -b6666</param-value>
    </init-param>
</servlet>
-----------------

    Note that the lifecycle of the application is the same as the servlet.
    When the servlet is undeployed, the jFastCGI library will try to stop the program aggressively
    (by calling
    {{{http://download.oracle.com/javase/6/docs/api/java/lang/Process.html#destroy()}java.lang.Process.destroy()}} method).

    Beware: There is currently no mechanism to restart the application if it crashes.
    You have to take care of this yourself and take appropriate precautions.

Filtering http headers

    For security reasons, you might want to filter certain http headers that are present in the original request.

-----------------
<servlet>
    <servlet-name>FastCGI</servlet-name>
    <servlet-class>org.jfastcgi.servlet.FastCGIServlet</servlet-class>
    <init-param>
        <param-name>server-address</param-name>
        <param-value>localhost:6666</param-value>
    </init-param>
    <init-param>
        <param-name>filtered-headers</param-name>
        <param-value>Authorization;</param-value>
    </init-param>
</servlet>
-----------------

    The filtered-headers parameter is a semicolon (the ";" character) separated list of the headers that WILL not be translated into parameters for the fastCGI process.
    In this example the HTTP_AUTHORIZATION parameters will be absent in requests passed to the target application.

Using several connections for the same app

    If the fastCGI application accepts it, several host/port couples may be used to serve the pages.
    The FastCGI servlet will choose one of the provided address,
    and use the connection for serving the page.

    This configuration is done by providing a semicolon-separated list of addresses to the servlet configuration :

-----------------
<servlet>
    <servlet-name>FastCGI</servlet-name>
    <servlet-class>org.jfastcgi.servlet.FastCGIServlet</servlet-class>
    <init-param>
        <param-name>cluster-adresses</param-name>
        <param-value>localhost:6666;host1:6666;host2:6666</param-value>
    </init-param>
</servlet>
-----------------

    By default, the fastCGI connection that will be used to build a response is chosen randomly when a request arrives.

Doing fancy things: writing a custom ConnectionFactory

    You may want to provide a more complex algorithm for creating and keeping the fastCGI tcp connections.
    You do this by creating your own ConnectionFactory. Just implement
    {{{https://github.com/jFastCGI/jfastcgi/blob/master/client/core/src/main/java/org/jfastcgi/api/ConnectionFactory.java}org.jfastcgi.api.ConnectionFactory}}
    and register it with the servlet like this:

-----------------
<servlet>
    <servlet-name>FastCGI</servlet-name>
    <servlet-class>org.jfastcgi.servlet.FastCGIServlet</servlet-class>
    <init-param>
        <param-name>connection-factory</param-name>
        <param-value>com.mycompany.fastcgi.MyFancyConnectionHandler</param-value>
    </init-param>
</servlet>
-----------------

* Using Spring instead of plain servlets

** pre-requisite :

    You know how to use Spring, and in particular Spring's
    {{{http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/web/servlet/DispatcherServlet.html}DispatcherServlet}}

    If you use spring, you may register a handler instead of the servlet, in particular if you use a complex configuration.

    The configuration is done through spring :

-----------------
    <bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
        <property name="mappings">
            <value>
                **.php=fastCGIRequestHandler
            </value>
        </property>
    </bean>

    <bean id="fastCGIRequestHandler" class="org.jfastcgi.spring.RequestHandler">
        <property name="connectionFactory" ref="connectionFactory" />
    </bean>

    <bean id="connectionFactory" class="org.jfastcgi.client.SingleConnectionFactory">
        <constructor-arg value="localhost:9763"/>
    </bean>
-----------------

    Note that the SingleConnectionFactory can be replaced with a PooledConnectionFactory, or any class that implements org.jfastcgi.api.ConnectionFactory.

Using portlets

    The configuration of the portlet is similar to the servlet. Just declare the portlet in your portlet.xml,

-----------------
<portlet>
    <portlet-name>sample_fastci_app</portlet-name>
    <display-name>Sample FastCGI Application</display-name>
    <portlet-class>org.jfastcgi.portlet.FastCGIPortlet</portlet-class>
    <init-param>
        <name>server-address</name>
        <value>localhost:6666</value>
    </init-param>
    <supports>
        <mime-type>text/html</mime-type>
        <portlet-mode>view</portlet-mode>
    </supports>
    <porlet-info>
        <title>My portlet</title>
    </portlet-info>
</portlet>
-----------------
    All the parameters that would be accepted for servlet configuration
    (server-address, cluster-adresses, filtered-headers,...)
    will be accepted for the portlet configuration.

